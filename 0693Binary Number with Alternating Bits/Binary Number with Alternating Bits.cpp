class Solution {//利用交替位二進制樹中0、1交替出現的性質，找到更快速的判斷方式
public:
    bool hasAlternatingBits(int n) {
        long long cur = n ^ (n>>1);//XOR(^)如果 n 是 0、1 交替的（如 1010...），那麼 n 與其右移一位的結果進行 XOR(^) 運算後，每一位都會變成 1;將 n 的二進制位向右移動一格。
        cur++;//只有最高位是 1，其餘全是 0。如果 cur 所有的位元都是 1（如 111_2=7），那麼 cur++ 之後會變成一個 2 的冪次方（如 (1000_2=8)）
        return(cur & (cur - 1)) == 0;//判斷一個數是否為 2 的冪次方
    }
};
/*& 符號
身份 A：抓位址 (Address-of)
用法：放在變數前面，且前面沒有類型。
範例：int* p = &n;（這裡的 & 是叫電腦：「把 n 的記憶體地址給我」。）
身份 B：引用 (Reference)
用法：放在類型後面。
範例：void func(vector<int>& nums)（這裡的 & 是叫電腦：「直接用原本的資料，不要複製」。）
身份 C：位元運算 AND (Bitwise AND)
用法：放在兩個數字中間。
範例：5 & 1（這是在做電路級的邏輯運算，也就是你剛才程式碼裡的用法。）
^ 符號 
在 C++ 中：^ 不是次方。 它只有一個身份：位元異或 (XOR)。範例：5 ^ 3 結果是 6，而不是 125。在 C++ 的「次方」怎麼寫？要使用函式庫中的 pow(base, exp)，例如 pow(2, 3)。
*/
